. todo
 . mettre en place l automate de recalage
  . si on est trop pret d un mur alors que l asserv ne le voit
  pas, se recaler

 . path_xxx api -> on veut pouvoir rajouter des points de passage
  . actuellement, si on veut aller d un point a un autre
  tout en contournant les objets, c est difficile. A priori,
  le terrain va etre encombre et il faut profiter des deplacements
  pour remttre sur nos cases un max de pions possible lors des
  deplacements

 . exporter les fonctions de tiling, et maintient des etats des tiles

 . mieux modeliser les sharps, tester que les assumptions
 faites sont correctes. notament pour la distance min/max fiables,
 et la perte sur la distance

 . avant de passer dans l automat distri, il faudrait
  degager le 2 pions qui trainent (?)
 . implementer un automate de prise des pions en fonction
  de la configuration
  . implementer les configurations de test associees
 . il faudrait un master automata qui drive les autres
  . d abord distri, ensuite wander, dans wander -> taker...

 . mettre en place les side corner sharps
  -> bot._sharp[xxx].set_info() pas encore fait
  . les utiliser
   . d une part pour savoir si on passe devant un obstacle
   qui sera par la suite detecte par le side sharp du milieu
   . d autre part pour assurer une distance mini avec les murs
    -> impossible avec le side sharp du milieu puisqu il peut
    voir le mur trop tard

 . bugs
  . wander strat -> dont move back while placing pawns
   . more generally, better handling of collision, dont
   use a wait_done

 . devices
  . puissance des sharps
   . actuellement 10000, eq. a infini

  . container: a bot can contain some pawn
   . the clamp moves the pawn in a container of size 1 per default

  . implement switches at each corners
   . implement as sharp with a very small distance ?
   . should have an aperture in that case...
   . more simple to implement it by walking object list

  . add red blue under the robot so that the robot can continue playing even if the asserv gets lost
   . create the redblue.cc
   . implement the corresponding strategy

  . rename sensor.cc to sharp.cc

 . strategy

 . documentation guide
  . specifier les reperes
   . tous les reperes (local du robot...)
   . 0 degree points on the right
   . 90 degree points on the bottom 
   . (0, 0) top left corner

 . optimisation, code
  . should the global update routine be called at the
    end of cpSpaceStep instead of velocity update?
  . cpShape->sensor can be used to implement a sensor more efficiently
  . factorize tile code in tile.{hh,cc}
  . cache a surface for bot, update only when angle changes
   . in asserv.next(), set body->flags | NEED_GRAPHICS_UPDATE;
   . in draw_shape, recompute the surface

. features
 . state snapshot
  . snap::load, snap::store
 . implement friction ?
  . -> at least the robot should not bounce indefinitly like a ball...
  . angular velocity should be a function of velocity and wheels circumference

. programming concept
 . la programmation du robot repose sur 2 concepts
  . une strategie
  . un ensemble d automates
 . la strategie est le comportement general qu adopte le robot. les actions basiques
 de la strategie s appuient sur un ou plusieurs automates
  . description des strategies
   . pour le moment, seule une strategie floue est definie
  . description des automates
   . automate sortie de zone de depart
   . automate vidange de la zone de distribution
   . automate moveto
   . automate deplacement de pion
   . automate deplacement de tour
  . on devrait avoir un automate pour tout: turn, turn_safe...

. references
 . line intersection
  . http://alienryderflex.com/intersect/

. recording linux desktop
 . ffmpeg -f x11grab -s `xdpyinfo | grep 'dimensions:'|awk '{print $2}'` -r 25 -i :0.0 /tmp/out.mpg