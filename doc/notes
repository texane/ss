. todo
 . avant de passer dans l automat distri, il faudrait
  degager le 2 pions qui trainent (?)
 . implementer un automate de prise des pions en fonction
  de la configuration
  . implementer les configurations de test associees
 . il faudrait un master automata qui drive les autres
  . d abord distri, ensuite wander, dans wander -> taker...

 . mettre en place les side corner sharps
  -> bot._sharp[xxx].set_info() pas encore fait
  . les utiliser
   . d une part pour savoir si on passe devant un obstacle
   qui sera par la suite detecte par le side sharp du milieu
   . d autre part pour assurer une distance mini avec les murs
    -> impossible avec le side sharp du milieu puisqu il peut
    voir le mur trop tard

 . bugs
  . wander strat -> dont move back while placing pawns
   . more generally, better handling of collision, dont
   use a wait_done

 . devices
  . puissance des sharps
   . actuellement 10000, eq. a infini

  . container: a bot can contain some pawn
   . the clamp moves the pawn in a container of size 1 per default

  . implement switches at each corners
   . implement as sharp with a very small distance ?
   . should have an aperture in that case...
   . more simple to implement it by walking object list

  . add red blue under the robot so that the robot can continue playing even if the asserv gets lost
   . create the redblue.cc
   . implement the corresponding strategy

  . rename sensor.cc to sharp.cc

 . strategy

 . documentation guide
  . specifier les reperes
   . tous les reperes (local du robot...)
   . 0 degree points on the right
   . 90 degree points on the bottom 
   . (0, 0) top left corner

 . optimisation, code
  . should the global update routine be called at the
    end of cpSpaceStep instead of velocity update?
  . cpShape->sensor can be used to implement a sensor more efficiently
  . factorize tile code in tile.{hh,cc}
  . cache a surface for bot, update only when angle changes
   . in asserv.next(), set body->flags | NEED_GRAPHICS_UPDATE;
   . in draw_shape, recompute the surface

. features
 . state snapshot
  . snap::load, snap::store
 . implement friction ?
  . -> at least the robot should not bounce indefinitly like a ball...
  . angular velocity should be a function of velocity and wheels circumference

. references
 . line intersection
  . http://alienryderflex.com/intersect/

. recording linux desktop
 . ffmpeg -f x11grab -s `xdpyinfo | grep 'dimensions:'|awk '{print $2}'` -r 25 -i :0.0 /tmp/out.mpg